---
title: 'Feature Flags Part 1 - Understanding the Fundamentals'
description: 'Part 1 of my feature flags series: Learn the core concepts, different types of controls, and common patterns in feature flag implementation'
date: 2025-02-02
tags: ['architecture', 'best-practices', 'feature-flags']
series: 'feature-flags'
authors: ['bdestrempes']
draft: false
---

# Feature Flags - Understanding the Fundamentals

> [!NOTE]  
> This is Part 1 of the [comprehensive guide to feature flags](/articles/feature-flags-series-introduction). In this article, we'll explore core concepts and implementation strategies for effective feature management.

## Introduction

Feature flags are a powerful technique that enables teams to modify system behavior without changing code. Whether you're just starting with simple toggles or building complex feature management systems, understanding the fundamentals is crucial for success.

In this guide, you'll learn:

- Core concepts and different types of feature controls
- Common implementation patterns and challenges
- Best practices for scalable feature management
- Real-world considerations and trade-offs

---

Most development teams start their feature flag journey with simple `true`/`false` toggles, usually with the confident declaration "We'll keep it simple!" (they definitely did not keep it simple). Take this basic example from an e-commerce application:

```typescript
if (flags.isEnabled('new-checkout')) {
  return <NewCheckoutFlow />;
} else {
  return <CurrentCheckoutFlow />;
}
```

This approach works well enough at first. But as teams start seeing the benefits of feature flags, they inevitably want to do more with them. What started as a simple toggle often evolves into a complex system as applications scale and teams mature. Feature management needs expand to include:

- Progressive rollouts and canary deployments
- A/B testing and user segmentation
- System configuration and operational controls
- Enterprise customer customization

This natural evolution leads teams to evaluate two primary implementation paths:

- **Platform Solutions**: Tools like [LaunchDarkly](https://launchdarkly.com/), [Unleash](https://getunleash.io/), and [Flagsmith](https://flagsmith.com/) offer comprehensive feature management capabilities. Each has its strengths: enterprise scalability, self-hosting options, and open-source flexibility, respectively.

- **In-House Development**: Some teams opt to build custom solutions. While this starts simple, it often grows to encompass:
  - Sophisticated targeting rules
  - Performance monitoring
  - Integration with existing systems
  - Custom business requirements

The decision between these approaches extends beyond feature comparison‚Äîit's about aligning with your team's resources, expertise, and long-term maintenance capacity.

## Why Implement Feature Flags?

Feature flags have evolved from simple deployment tools into essential infrastructure for modern software development. They enable teams to:

1. **Deploy Continuously**: Ship code independently of feature releases
2. **Release Gradually**: Roll out features to specific user segments
3. **Mitigate Risk**: Quickly disable problematic features
4. **Test in Production**: Run experiments with real users
5. **Target Precisely**: Customize experiences for different users
6. **Configure Dynamically**: Adjust system behavior without deployments
7. **Support Enterprise**: Manage customer-specific feature sets

> [!NOTE]
> Modern applications often require a combination of feature flags, access controls, and entitlements. Understanding how these systems complement each other is crucial for building robust applications.

## Core Concepts and Control Types

Modern applications typically employ three fundamental types of controls: feature flags, RBAC (Role-Based Access Control), and entitlements. Each serves distinct purposes but requires careful integration.

### 1. Feature Flags

Feature flags typically serve as temporary toggles for controlled rollouts and experimentation. They're often most effective when used for deploying new functionality gradually.

Common characteristics:

- **Duration**: Often temporary, removed after full rollout
- **Targeting**: Can target specific users, regions, or percentages
- **Changes**: Can be modified without deployment
- **Usage**: Frequently used for A/B testing

Consider this example of feature flag configuration:

```json showLineNumbers
{
  "flags": {
    "new-checkout": {
      "name": "New Checkout Experience",
      "enabled": true,
      "rollout": {
        "percentage": 25
      }
    }
  }
}
```

The corresponding application code remains focused on the feature itself:

```typescript showLineNumbers
if (featureFlags.isEnabled('new-checkout')) {
  return <NewCheckoutFlow />;
} else {
  return <CurrentCheckoutFlow />;
}
```

The feature flag service evaluates which users see the feature based on the configuration.

### 2. Role-Based Access Control (RBAC)

RBAC typically serves as a security mechanism for controlling user permissions based on roles.

Common characteristics:

- **Duration**: Usually a permanent part of security model
- **Structure**: Often involves role hierarchies
- **Focus**: Frequently tied to compliance requirements
- **Purpose**: Controls user permissions

```typescript showLineNumbers
// Example of role-based permissions
interface Role {
  name: string
  permissions: string[]
  inheritsFrom?: Role[]
}

const adminRole: Role = {
  name: 'admin',
  permissions: ['manage.users', 'view.analytics'],
  inheritsFrom: [editorRole],
}

// Permission check with inheritance
if (rbac.can(user, 'manage.users')) {
  showUserManagement()
}
```

### 3. Entitlements

Entitlements typically handle access based on business rules like subscription levels or purchases.

Common characteristics:

- **Focus**: Often tied to business strategy
- **Basis**: Usually linked to payment tiers
- **Duration**: Tends to follow business model
- **Scope**: Often involves contractual obligations

Here's how entitlements might be configured:

```json showLineNumbers
{
  "features": {
    "advanced-analytics": {
      "name": "Advanced Analytics",
      "requiredTier": "pro",
      "limits": {
        "queries-per-day": 1000,
        "data-retention-days": 90
      }
    }
  }
}
```

And how they're checked in the application code:

```typescript showLineNumbers
if (await entitlements.can(user, 'advanced-analytics')) {
  return <AdvancedAnalytics />;
} else {
  return <BasicAnalytics />;
}
```

The entitlements service handles checking the user's subscription tier, usage limits, and any other business rules.

### Comparison of Approaches

Here's how these different controls often compare:

| Aspect        | Feature Flags          | RBAC                     | Entitlements                |
| ------------- | ---------------------- | ------------------------ | --------------------------- |
| Duration      | Often temporary        | Usually permanent        | Follows business needs      |
| Purpose       | Deployment & testing   | Access control           | Business model support      |
| Change Rate   | Can be frequent        | Typically infrequent     | Follows business changes    |
| Configuration | Runtime changes common | Often set at deploy time | Based on customer contracts |
| Focus         | Technical deployment   | Organizational structure | Business rules              |

> [!NOTE]
> Each approach has its uses. Mixing them too much might make your system harder to maintain and understand.

### Integration Patterns

A typical approach to combining these systems might look like this:

```typescript showLineNumbers
// Example of combining different controls
async function canAccessFeature(
  user: User,
  feature: string,
  context: Context,
): Promise<boolean> {
  // Check if the feature is available
  const isFeatureEnabled = await featureFlags.isEnabled(feature, context)
  if (!isFeatureEnabled) return false

  // Check user permissions
  const hasPermission = await rbac.can(user, `access.${feature}`)
  if (!hasPermission) return false

  // Check subscription status
  const hasEntitlement = await entitlements.check(user, feature)
  return hasEntitlement
}

// Usage example
if (await canAccessFeature(user, 'advanced-analytics', context)) {
  showAdvancedAnalytics()
}
```

## Common Implementation Challenges

As teams adopt feature flags, they often encounter several common challenges. Understanding these challenges early can help you make better decisions about your implementation approach.

### 1. Flag Lifecycle and Cleanup

> [!CAUTION]  
> Feature flag complexity grows exponentially with each new flag added. Without proper management, this can lead to technical debt and maintenance challenges.

While best practices suggest keeping feature flags temporary and minimal, real-world development often presents more complex scenarios. It's easy to add flags, but teams frequently face challenges with their ongoing management.

Let me share a typical story of how feature flag complexity grows over time (one that definitely isn't based on personal experience... üòÖ):

```typescript showLineNumbers
// Initial implementation
if (featureFlags.isEnabled('new-checkout-flow')) {
  return <NewCheckout />;
} else {
  return <LegacyCheckout />;
}

// Several months later...
if (featureFlags.isEnabled('new-checkout-flow')) {
  if (featureFlags.isEnabled('payment-provider-switch')) {
    return <NewCheckoutWithNewPayment />;
  }
  return <NewCheckout />;
} else {
  // ‚ÅâÔ∏è Is this still needed?
  // ü§î Nobody remembers and everyone's too afraid to remove it
  return <LegacyCheckout />;
}

// 2 years later...
// üôà We don't talk about what this grew into
```

Over time, this accumulation of flags can lead to several challenges:

- **Legacy Flags**: Flags intended to be temporary that persist in the codebase
- **Testing Complexity**: Multiple flag combinations increase testing requirements
- **Maintenance Burden**: Each flag increases system complexity
- **Documentation Drift**: Configuration and documentation can become outdated
- **Partial Deployments**: Features may remain in transition states

> [!NOTE]
> Consider implementing systematic solutions:
>
> - Define clear lifecycle policies for flags
> - Use tooling to monitor flag usage and status
> - Add automated checks in your CI pipeline
> - Establish clear ownership and review processes

Modern software development requires a balanced approach to flag management. While temporary flags are ideal, teams need robust processes to handle both short-term and long-lived flags effectively.

### 2. Performance Considerations

> [!WARNING]  
> Unoptimized feature flag implementations can significantly impact application performance, especially in client-side applications with multiple flag evaluations.

Feature flag evaluations often require network calls to check their state, which can impact application performance. This becomes particularly noticeable in modern web applications where multiple components might need to check feature flags simultaneously.

For example, imagine a dashboard page that loads several widgets, each needing to check if they should display a new or legacy version. If each widget makes its own feature flag check, this could result in multiple network requests firing at once. (This is a great way to learn that "429 Too Many Requests" isn't just a theoretical HTTP status code ü´†)

Fortunately, there are several proven strategies to maintain good performance:

- **Centralize Flag Fetching**: Avoid having individual components fetch their own flags scattered throughout the codebase. Instead, organize flag fetching at higher levels in your application (like the route or page level) and pass the values down to child components. This not only improves performance but also makes flag usage more maintainable and easier to track.

- **Batch Evaluations**: Instead of checking flags individually, fetch all needed flags for a page or component at once. This reduces network overhead and improves response times.

- **Smart Caching**: Cache flag values at appropriate levels (session, page load, etc.) to avoid unnecessary network calls. Consider cache invalidation strategies that balance freshness with performance.

- **Performance Monitoring**: Track flag evaluation latency and implement circuit breakers or fallbacks for when the feature flag service is slow or unavailable.

> [!TIP]
> Consider implementing a client-side SDK that handles batching, caching, and fallback strategies automatically. Many feature flag platforms provide these capabilities out of the box.

### 3. Separating Different Types of Controls

Teams sometimes blur the lines between feature flags, permissions, and entitlements. While it might seem convenient to combine these concerns, it often leads to maintenance headaches and unclear business logic.

Here's how this anti-pattern often appears:

```typescript showLineNumbers
// ‚ùå Anti-pattern: Mixed concerns
if (
  featureFlags.isEnabled('admin-dashboard') &&
  user.role === 'admin' &&
  user.subscription === 'premium'
) {
  return <AdminDashboard />;
}

// ‚úÖ Better: Clean separation of concerns
// First, check if user has access to the admin dashboard
const canAccessAdmin = await accessControl.check({
  feature: 'admin-dashboard',
  user,
  requiredRole: 'admin',
  requiredTier: 'premium'
});

if (!canAccessAdmin) {
  return <AccessDenied />;
}

// Then, handle UI variations with feature flags
const shouldUseNewUI = featureFlags.isEnabled('new-admin-ui');
return shouldUseNewUI ? <NewAdminDashboard /> : <AdminDashboard />;
```

Keeping these concerns separate helps:

- Maintain clear business logic
- Simplify testing and debugging
- Make code more maintainable
- Support clearer access control policies

> [!TIP]
> When implementing feature flags, try to keep each type of control focused on its primary purpose: feature flags for deployment control, RBAC for permissions, and entitlements for business rules.

## Alternative Perspectives

While we've covered the common approaches to feature flags, it's worth examining some counterpoints. After working with feature flags in large-scale systems, engineers often develop more nuanced views that challenge what we might consider "best practices".

### On Feature Flag Temporality

The conventional wisdom that "feature flags should be temporary" deserves scrutiny. In complex systems:

- Long-lived flags often serve valid architectural purposes, acting as configuration points that enable operational flexibility
- The distinction between "feature flags" and "system configuration" is sometimes artificial
- The cost of removing flags (testing, deployment, coordination) can outweigh their maintenance burden

### On Separating Concerns

While separating feature flags from permissions and entitlements appears clean, consider that:

- Real-world features often inherently combine multiple concerns
- Additional abstraction layers can increase system complexity
- The performance cost of multiple separate service calls might not justify the architectural purity

For example, imagine implementing a "Teams" feature in a SaaS application:

```typescript showLineNumbers
// ‚ùå Purely separated concerns at the component level...
async function TeamsFeature() {
  // We can at least run the checks concurrently
  const [isTeamsEnabled, hasTeamsPermission, teamsEntitlement] = await Promise.all([
    featureFlags.isEnabled('teams'),
    rbac.can(user, 'access.teams'),
    entitlements.check(user, 'teams')
  ]);

  // But we still have complex logic to handle all combinations
  if (!isTeamsEnabled) return <TeamsComingSoon />;
  if (!hasTeamsPermission) return <AccessDenied />;
  if (!teamsEntitlement.hasAccess) return <UpgradePrompt max={teamsEntitlement.limit} />;

  return <TeamsUI />;
}

// ‚úÖ A more pragmatic approach with an aggregation layer...
class TeamsService {
  async getTeamsAccess(params: { user: User; feature: string; context: Context }) {
    // Similar concurrent execution, but encapsulated in the service
    const [flags, permissions, entitlements] = await Promise.all([
      this.featureFlags.isEnabled(params.feature),
      this.rbac.can(params.user, `access.${params.feature}`),
      this.entitlements.check(params.user, params.feature)
    ]);

    // Aggregates results and provides a clean interface
    return {
      canAccess: flags && permissions && entitlements.hasAccess,
      limit: entitlements.limit,
      renderFallback: () => this.getFallbackUI({ flags, permissions, entitlements })
    };
  }
}

// In your component:
async function TeamsFeature() {
  // One call that combines all checks
  const teams = await teamService.getTeamsAccess({
    user,
    feature: 'teams',
    context
  });

  // Simpler logic, still maintainable
  if (!teams.canAccess) return teams.renderFallback();
  return <TeamsUI maxTeams={teams.limit} />;
}
```

This example shows different approaches to managing multiple concerns. While putting all checks directly in the component can lead to performance and maintenance issues, we can maintain clean separation of concerns through a well-designed aggregation layer. This gives us the best of both worlds: clean architecture in our services with pragmatic usage in our components.

### On Performance Optimization

The suggested performance optimizations come with their own tradeoffs. For example:

```typescript showLineNumbers
class FeatureProvider {
  private cache = new Map<string, CacheEntry>()

  async getFeatures(context: Context): Promise<FeatureSet> {
    // Centralized fetching seems clean, but...
    try {
      const features = await this.fetchAllFeatures(context)

      // ‚ùì What if only some features fail to fetch?
      // ‚ùì What if some features need different refresh rates?
      // ‚ùì What if different components need different contexts?

      return features
    } catch (error) {
      // Do we fall back to cache? Partial results?
      // How do we handle cache staleness?
      return this.handleError(error)
    }
  }

  // A slightly more nuanced approach might be better
  async getFeaturesByComponent(
    component: string,
    context: Context,
  ): Promise<FeatureSet> {
    // Allow components to manage their own feature states
    // Accept some duplication for better reliability
    const features = await this.fetchFeatures(component, context)
    return this.mergeCachedFeatures(features, component)
  }
}
```

These examples demonstrate that real-world implementations often require more nuanced approaches than general best practices might suggest. The key is understanding your specific requirements and constraints.

## Conclusion

Feature flags are a powerful tool in modern software development, but implementing them effectively requires careful consideration of various factors:

- Understanding the different types of controls and when to use each
- Planning for performance and scalability from the start
- Managing feature flag lifecycle and technical debt
- Balancing architectural purity with practical constraints

Remember that there's no one-size-fits-all solution. The key is to understand your specific requirements and constraints, then design a system that works for your team and organization.

## What's Next

In this article, we've explored different approaches to feature flags and some common implementation patterns. In Part 2: Implementing Feature Flags at Scale, we'll look at various ways to implement feature flags in larger applications.
