---
title: 'Feature Flags Part 2 - Implementation at scale'
description: 'Part 2 of our feature flags series: Exploring approaches to implement feature flag systems that scale with your application'
date: 2025-02-02
tags: ['architecture', 'best-practices', 'feature-flags']
series: 'feature-flags'
authors: ['bdestrempes']
draft: false
---

# Feature Flags - Implementation at scale

> [!NOTE]
> This is Part 2 of our [comprehensive guide to feature flags](/articles/feature-flags-series-introduction). In this article, we'll explore proven approaches to implementing feature flags in larger applications.

## Introduction

After exploring the [fundamentals of feature flags](/articles/feature-flags-fundamentals), we'll dive into scalable implementation patterns. We'll examine real-world solutions that can be used to maintain and scale feature flag systems.

While this article covers somewhat sophisticated implementations, smaller applications may be better served by simpler approaches like environment variables or simple database flags. Choose the complexity level that matches your needs.

Let's explore how to take your feature flags from "it's just an if statement" to "wow, this actually works!"

## Configuration Management Approaches

> [!IMPORTANT]
> The configuration management system you choose will significantly impact your feature flag system's reliability, performance, and maintainability. Consider your requirements carefully.

As applications grow, managing feature flag configuration becomes increasingly critical. This criticality stems from several factors: the growing number of flags to manage, the increasing complexity of rollout rules, the need for quick changes across distributed systems, and the importance of maintaining consistent behavior across your entire application. Poor configuration management can lead to inconsistent user experiences, delayed feature releases, and even system outages. Conversely, a well-designed configuration system enables rapid feature deployment, reliable rollbacks, and confident decision-making based on clear flag states.

### Configuration Store Patterns

When designing a configuration store, consider these important factors. Each factor plays a crucial role in building a reliable and scalable feature flag system, and the implementation choices you make here will significantly impact your system's behavior under various conditions.

#### Availability: Handling Outages Gracefully

Your feature flag system needs to work even when the configuration service is down. This is critical because feature flag failures can cascade into application-wide issues. One way to achieve high availability is by implementing local caching with sensible defaults. This creates multiple layers of fallback:

1. First, try to get the latest configuration
2. If that fails, use cached values if they're still valid
3. Finally, fall back to conservative defaults

```typescript showLineNumbers
class ConfigurationStore {
  private localCache: Map<string, FeatureConfig>
  private lastSuccessfulFetch: Date | null = null
  private readonly maxCacheAge = 1000 * 60 * 1 // 1 minute

  async getConfig(feature: string): Promise<FeatureConfig> {
    try {
      // Try to get fresh config, we can add retries in case of network issues
      return await this.fetchConfig(feature)
    } catch (error) {
      // On failure, check cache
      const cached = this.localCache.get(feature)
      if (cached && this.isCacheValid()) {
        return cached
      }

      // Fall back to defaults if cache is stale
      return {
        name: feature,
        enabled: false, // Conservative default
        rules: [],
        lastUpdated: new Date(),
      }
    }
  }

  private isCacheValid(): boolean {
    if (!this.lastSuccessfulFetch) return false
    const cacheAge = Date.now() - this.lastSuccessfulFetch.getTime()
    return cacheAge < this.maxCacheAge
  }
}
```

#### Consistency: Reliable Change Propagation

When updating feature flags, you need to ensure all application instances see the changes within a reasonable timeframe. This is particularly challenging in distributed systems where multiple servers or services might be using the same feature flags. Inconsistent flag states across your system can lead to:

- Users seeing different experiences as they're load-balanced across servers
- Data inconsistencies when some services use old flag values
- Race conditions during flag updates
- Difficulty troubleshooting issues when you're unsure which flag state caused a problem

A robust change propagation system typically involves:

1. A central source of truth for flag configuration
2. A mechanism to notify all instances of changes (pub/sub, webhooks, etc.)
3. Version tracking to detect out-of-date configurations
4. Local caching with quick invalidation when updates occur

```typescript showLineNumbers
class ConsistentConfigStore {
  private readonly pubsub: PubSubClient
  private store: ConfigurationStore

  constructor() {
    // Subscribe to configuration changes
    this.pubsub.subscribe('feature-updates', async (message) => {
      const { feature, updatedAt } = message
      await this.refreshFeature(feature, updatedAt)
    })
  }

  async updateFeature(feature: string, config: FeatureConfig): Promise<void> {
    const updatedAt = new Date()

    try {
      // Update storage with timestamp
      await this.store.save(feature, {
        ...config,
        updatedAt, // We could also use a version number here to avoid race conditions
      })

      // Notify other instances
      await this.pubsub.publish('feature-updates', {
        feature,
        updatedAt,
        updatedBy: config.updatedBy,
      })

      // Update local cache immediately
      await this.refreshFeature(feature, updatedAt)
    } catch (error) {
      throw error
    }
  }

  private async refreshFeature(
    feature: string,
    updatedAt: Date,
  ): Promise<void> {
    const current = await this.store.getLastUpdate(feature)

    // Only refresh if our version is behind
    if (!current || current < updatedAt) {
      await this.store.refresh(feature)
    }
  }
}
```

> [!TIP]
> For applications requiring immediate updates, consider using [WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) or [Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) instead of polling or pub/sub systems.

#### History: Change Tracking and Rollbacks

Maintain a history of configuration changes in persistent storage to support rollbacks and auditing. This is more than just a nice-to-have feature - it's essential for several reasons:

- **Risk Mitigation**: When a feature flag change causes issues, you need to be able to quickly revert to a known good state
- **Compliance**: Many industries require audit trails of all system changes
- **Debugging**: Historical data helps understand when and why issues started occurring
- **Change Management**: Teams can review recent changes and their impact before making new changes

A comprehensive change tracking system should provide:

1. Complete history of all flag changes with metadata (who, when, why)
2. Multiple rollback strategies (previous version, specific version, time-based)
3. Ability to preview changes before applying them
4. Audit logs for compliance and debugging

```typescript showLineNumbers
interface ConfigurationChange {
  id: string
  feature: string
  previousValue: FeatureConfig
  newValue: FeatureConfig
  timestamp: Date
  author: string
  reason: string
}

class VersionedConfigStore {
  private readonly historyStore: HistoryStorage // Persistent storage interface

  // Record changes when updating features
  async updateFeature(
    feature: string,
    config: FeatureConfig,
    metadata: { author: string; reason: string },
  ): Promise<void> {
    const previous = await this.store.get(feature)
    const change: ConfigurationChange = {
      id: crypto.randomUUID(),
      feature,
      previousValue: previous,
      newValue: config,
      timestamp: new Date(),
      ...metadata,
    }

    await Promise.all([
      this.store.save(feature, config),
      this.historyStore.recordChange(change),
    ])
  }

  // Get recent changes for a feature
  async getHistory(
    feature: string,
    limit = 10,
  ): Promise<ConfigurationChange[]> {
    return this.historyStore.getChanges(feature, limit)
  }

  // Rollback to previous version
  async rollbackToPrevious(feature: string): Promise<void> {
    const changes = await this.getHistory(feature, 2)
    if (changes.length < 2) {
      throw new Error(`No previous version found for ${feature}`)
    }

    await this.updateFeature(feature, changes[1].newValue, {
      author: 'system',
      reason: 'Rollback to previous version',
    })
  }

  // Rollback by steps (e.g., go back 3 versions)
  async rollbackBySteps(feature: string, steps = 1): Promise<void> {
    const changes = await this.getHistory(feature, steps + 1)
    if (changes.length <= steps) {
      throw new Error(`Not enough history to rollback ${steps} steps`)
    }

    await this.updateFeature(feature, changes[steps].newValue, {
      author: 'system',
      reason: `Rollback ${steps} versions`,
    })
  }
}
```

> [!TIP]
> Provide multiple ways to rollback changes. Different situations call for different approaches—sometimes you want to go back one version, sometimes several.

This implementation offers several benefits:

1. Automatic change tracking
2. Simple rollback methods
3. Ability to view history before rolling back
4. Flexible rollback strategies for different needs

#### Auditing: Tracking Changes

We can leverage our existing `HistoryStorage` to implement auditing, since it already tracks all changes. A robust auditing system is crucial for several key purposes:

- **Security & Compliance**: Track who made what changes and when, essential for regulatory requirements and security audits
- **Operational Insights**: Understand patterns in how features are being managed and identify potential process improvements
- **Problem Resolution**: Quickly identify recent changes that might have contributed to system issues
- **Team Coordination**: Help teams understand what changes other teams have made, especially important in large organizations

An effective audit system should capture:

1. All changes to flag configurations
2. Metadata about each change (user, timestamp, reason)
3. The complete before and after state
4. Environmental context (production, staging, etc.)
5. Related system events (deployments, incidents)

```typescript showLineNumbers
class AuditedConfigStore extends VersionedConfigStore {
  async getAuditLog(
    feature: string,
    options: {
      startDate?: Date
      endDate?: Date
      limit?: number
    } = {},
  ): Promise<AuditLog[]> {
    const changes = await this.historyStore.getChanges(
      feature,
      options.limit ?? 100,
    )

    return changes.map((change) => ({
      id: change.id,
      feature: change.feature,
      action: change.previousValue ? 'update' : 'create',
      user: change.author,
      timestamp: change.timestamp,
      changes: this.diffConfigs(change.previousValue, change.newValue),
      metadata: {
        environment: process.env.NODE_ENV,
        reason: change.reason,
      },
    }))
  }

  private diffConfigs(
    oldConfig: FeatureConfig | null,
    newConfig: FeatureConfig,
  ): Array<{
    field: string
    oldValue: unknown
    newValue: unknown
  }> {
    if (!oldConfig) {
      return [
        {
          field: 'config',
          oldValue: null,
          newValue: newConfig,
        },
      ]
    }

    // Simple JSON comparison
    const oldJson = JSON.stringify(oldConfig, null, 2)
    const newJson = JSON.stringify(newConfig, null, 2)

    if (oldJson === newJson) {
      return [] // No changes
    }

    return [
      {
        field: 'config',
        oldValue: oldConfig,
        newValue: newConfig,
      },
    ]
  }
}
```

This approach:

1. Reuses our existing history storage
2. Provides consistent tracking of all changes
3. Avoids duplicate storage of change data
4. Maintains a single source of truth for feature changes

> [!TIP]
> While this simplified diff approach loses some granularity, it's often sufficient for auditing purposes and much easier to maintain. If you need field-level diffs, consider using a dedicated diffing library.

These patterns can be mixed and matched based on your needs. For example, you might start with just the availability pattern and add auditing later as your system grows.

### Caching Strategies

Let's talk about caching - because nobody wants their feature flag system to be the reason their application is slow! Effective caching is essential for both performance and reliability. In high-traffic applications, feature flag checks can happen thousands of times per second, and each check needs to be fast and reliable.

A multi-layered caching strategy helps balance speed with consistency. Local memory caches provide the fastest possible response times, while distributed caches ensure consistency across your application. When a cache miss occurs or data becomes stale, the system gracefully degrades through progressively slower but more authoritative data sources.

The key challenge is maintaining the right balance between performance and staleness - cached values that are too old can lead to inconsistent behavior, while overly aggressive cache invalidation can negate the performance benefits.

```typescript showLineNumbers
class CachedFeatureManager {
  private localCache: Map<string, CacheEntry>
  private redis: Redis
  private configStore: ConfigStore

  constructor() {
    this.localCache = new Map()
    this.redis = new Redis()
    this.configStore = new ConfigStore()
  }

  async isEnabled(feature: string, context: Context): Promise<boolean> {
    const cacheKey = this.getCacheKey(feature, context)

    // 1. Check local memory cache first (fastest)
    const localResult = this.localCache.get(cacheKey)
    if (localResult && !localResult.isExpired()) {
      return localResult.value
    }

    // 2. Check distributed cache
    const redisResult = await this.redis.get(cacheKey)
    if (redisResult !== null) {
      // Update local cache
      this.localCache.set(cacheKey, {
        value: redisResult === 'true',
        expiresAt: Date.now() + 5 * 60 * 1000, // 5 minutes
      })
      return redisResult === 'true'
    }

    // 3. Fall back to config store
    try {
      const result = await this.configStore.isEnabled(feature, context)

      // Update both caches
      await this.redis.set(cacheKey, String(result), 'EX', 300) // 5 minutes
      this.localCache.set(cacheKey, {
        value: result,
        expiresAt: Date.now() + 5 * 60 * 1000,
      })

      return result
    } catch (error) {
      // 4. Use fallback value if everything fails
      return this.getFallbackValue(feature)
    }
  }

  private getCacheKey(feature: string, context: Context): string {
    // Include relevant context in cache key
    return `flag:${feature}:${context.userId}:${context.environment}`
  }

  private getFallbackValue(feature: string): boolean {
    // Conservative defaults for different feature types
    const defaults = {
      'new-ui': false, // Default to old UI
      'danger-feature': false, // Default to safe mode
      'performance-opt': true, // Default to better performance
    }
    return defaults[feature] ?? false
  }
}
```

> [!TIP]
> Cache invalidation is hard! Keep your cache TTLs short (minutes, not hours) and make sure you have a way to force-invalidate when needed.

This implementation provides:

1. Fast local cache access for frequent checks
2. Distributed caching for consistency across instances
3. Fallback values for resilience
4. Automatic cache updates to keep data fresh

Remember: The goal is to make feature flag checks as fast and reliable as possible. Your users won't care about your fancy gradual rollout if it takes 2 seconds to load their page!

## Gradual Rollout Approaches

Feature flags are the foundation of controlled rollouts, enabling you to manage feature releases with precision. While a simple feature flag might be a binary on/off switch, sophisticated rollout strategies use flags to create nuanced, controlled deployment patterns.

### Core Rollout Strategies

#### Percentage-Based Rollouts

The most common use of feature flags for gradual rollouts. Rather than simple random selection, implement deterministic percentage-based flags using consistent hashing:

```typescript showLineNumbers
class PercentageRollout {
  private readonly hashFunction: (input: string) => number
  private readonly featureFlags: FeatureFlagService

  async shouldEnableFeature(
    flagName: string,
    userId: string,
  ): Promise<boolean> {
    const flag = await this.featureFlags.getFlag(flagName)
    if (!flag.enabled) return false // Master flag check
    if (flag.percentage === 100) return true // Full rollout

    const hash = this.hashFunction(`${flagName}:${userId}`)
    const normalized = (hash % 100) + 1 // 1-100
    return normalized <= flag.percentage
  }
}
```

#### User Segment Rollouts

Combine feature flags with user segments to create targeted rollouts:

```typescript showLineNumbers
interface FeatureFlagRule {
  flagName: string
  segments: string[]
  isEnabled: boolean
}

class SegmentedRollout {
  private readonly featureFlags: FeatureFlagService
  private readonly userSegments: UserSegmentService

  async isFeatureEnabled(flagName: string, user: User): Promise<boolean> {
    const flag = await this.featureFlags.getFlag(flagName)
    if (!flag.enabled) return false // Master flag check

    // Check if user matches any enabled segments
    const userSegments = await this.userSegments.getSegmentsForUser(user)
    return flag.rules.some(
      (rule) =>
        rule.isEnabled &&
        rule.segments.some((segment) => userSegments.includes(segment)),
    )
  }
}
```

#### Sticky Rollouts

Use feature flags with persistent user preferences to ensure consistent experiences:

```typescript showLineNumbers
class StickyFeatureFlag {
  private readonly featureFlags: FeatureFlagService
  private readonly userPreferences: UserPreferenceStore

  async isEnabled(flagName: string, userId: string): Promise<boolean> {
    const flag = await this.featureFlags.getFlag(flagName)
    if (!flag.enabled) return false // Master flag check

    // Check for existing user preference
    const preference = await this.userPreferences.get(userId, flagName)
    if (preference !== null) return preference

    // Calculate and store new preference
    const newValue = await this.calculateEligibility(flag, userId)
    await this.userPreferences.set(userId, flagName, newValue)
    return newValue
  }
}
```

### Best Practices for Feature Flag Rollouts

1. **Flag Hierarchy**: Use a master flag for quick killswitch capability, with sub-flags for granular control
2. **Monitoring Integration**: Tie feature flag states to monitoring systems for quick issue detection
3. **Cleanup Strategy**: Plan flag removal as part of the rollout strategy
4. **Documentation**: Keep clear records of flag purposes and rollout decisions

> [!WARNING]
> Always ensure your feature flags have clear ownership and expiration strategies. Long-lived rollout flags can become technical debt if not properly managed.

This approach ensures your feature flags serve as a robust foundation for controlled, reliable feature rollouts.

## Monitoring and Analytics

Feature flags aren't just about controlling deployments - they're also a powerful source of operational and business insights. A well-instrumented feature flag system can help you understand both the technical and business impact of your features.

### Technical Metrics

Monitor the health and performance of your feature flag system:

```typescript showLineNumbers
class FeatureFlagMetrics {
  private readonly metrics: MetricsService
  private readonly logger: Logger

  async checkFeatureFlag(flagName: string, context: Context): Promise<boolean> {
    const timer = this.metrics.startTimer()

    try {
      const result = await this.featureFlags.isEnabled(flagName, context)

      // Record successful check
      this.metrics.increment('feature_flag.check.success', {
        flag: flagName,
        result: String(result),
      })

      // Record response time
      this.metrics.recordTiming('feature_flag.check.duration', timer(), {
        flag: flagName,
      })

      return result
    } catch (error) {
      // Record failures
      this.metrics.increment('feature_flag.check.error', {
        flag: flagName,
        error: error.name,
      })

      this.logger.error('Feature flag check failed', {
        flag: flagName,
        error,
        context,
      })

      throw error
    }
  }
}
```

### Business Impact Tracking

Connect feature flag states to business metrics to understand their impact:

```typescript showLineNumbers
class FeatureImpactTracker {
  private readonly analytics: AnalyticsService
  private readonly featureFlags: FeatureFlagService

  async trackConversion(userId: string, event: string): Promise<void> {
    // Get all active flags for this user
    const activeFlags = await this.featureFlags.getActiveFlags(userId)

    // Track conversion with flag context
    this.analytics.track(event, {
      userId,
      features: activeFlags,
      timestamp: new Date(),
    })
  }

  async generateImpactReport(
    flagName: string,
    startDate: Date,
    endDate: Date,
  ): Promise<ImpactMetrics> {
    const [enabledMetrics, disabledMetrics] = await Promise.all([
      this.analytics.query({
        event: 'conversion',
        filter: `features.${flagName} = true`,
        timeRange: { startDate, endDate },
      }),
      this.analytics.query({
        event: 'conversion',
        filter: `features.${flagName} = false`,
        timeRange: { startDate, endDate },
      }),
    ])

    return {
      conversionLift: calculateLift(enabledMetrics, disabledMetrics),
      sampleSize: enabledMetrics.length + disabledMetrics.length,
      confidence: calculateConfidence(enabledMetrics, disabledMetrics),
    }
  }
}
```

### Real-time Monitoring

Set up alerts for unusual feature flag behavior:

```typescript showLineNumbers
class FeatureFlagMonitor {
  private readonly alerting: AlertingService
  private readonly thresholds: MonitoringThresholds

  async checkHealthMetrics(): Promise<void> {
    // Monitor error rates
    const errorRate = await this.getErrorRate()
    if (errorRate > this.thresholds.maxErrorRate) {
      await this.alerting.notify('FeatureFlagErrorRate', {
        message: `Error rate of ${errorRate}% exceeds threshold`,
        severity: 'high',
      })
    }

    // Monitor response times
    const p95Latency = await this.getP95Latency()
    if (p95Latency > this.thresholds.maxLatency) {
      await this.alerting.notify('FeatureFlagLatency', {
        message: `P95 latency of ${p95Latency}ms exceeds threshold`,
        severity: 'medium',
      })
    }

    // Check for stuck rollouts
    const stuckRollouts = await this.findStuckRollouts()
    for (const rollout of stuckRollouts) {
      await this.alerting.notify('StuckRollout', {
        message: `Rollout ${rollout.flagName} hasn't progressed in ${rollout.daysSinceUpdate} days`,
        severity: 'low',
      })
    }
  }
}
```

> [!TIP]
> Set up dashboards that combine technical and business metrics to get a complete picture of your feature flags' impact.

The key is to treat your feature flag system as a critical part of your observability infrastructure. Good monitoring helps you:

1. Detect and diagnose issues quickly
2. Make data-driven decisions about feature rollouts
3. Understand the business impact of features
4. Identify opportunities for system optimization

Remember: Feature flags generate valuable data about both your system's health and your features' impact. Don't waste this opportunity to gain insights into your application's behavior and your users' experiences.

## Error Handling Best Practices

Nobody likes errors, but they're going to happen. Here's how to handle them gracefully:

1. **Define Fallback Values**: Always have a plan B
2. **Circuit Breaking**: Protect your system from cascading failures
3. **Graceful Degradation**: Ensure your application still works when flags fail

> [!TIP]
> Remember: A feature flag error should never break your application. If it does, you're doing it wrong!

### Error Handling and Defaults

When handling errors, prefer failing fast and visibly over silent fallbacks—this can vary based on the environment:

```typescript showLineNumbers
class FeatureManager {
  async isEnabled(feature: string, context: Context): Promise<boolean> {
    try {
      const result = await this.configStore.isEnabled(feature, context)
      return result
    } catch (error) {
      // Log error with full context for debugging
      this.logger.error('Feature flag check failed', {
        feature,
        context,
        error,
        stack: error.stack,
      })

      // Throw error instead of using fallback
      // This helps catch issues early in development/testing
      throw new FeatureFlagError(`Failed to check feature ${feature}`, {
        cause: error,
      })
    }
  }

  // Separate method for production use with fallbacks
  async isEnabledWithFallback(
    feature: string,
    context: Context,
  ): Promise<boolean> {
    try {
      return await this.isEnabled(feature, context)
    } catch (error) {
      // Still log the error
      this.logger.error('Using fallback for feature flag', {
        feature,
        context,
        error,
      })

      // Use fallbacks in production
      return this.getFallbackValue(feature)
    }
  }
}
```

## Conclusion

Building a scalable feature flag system requires careful planning, robust implementation, and continuous refinement.

The key to success lies not just in the technical implementation, but in creating a system that serves both your engineering team and your business needs. A well-designed feature flag system should:

- Provide rock-solid reliability with graceful degradation
- Scale seamlessly as your application grows
- Offer clear visibility into flag status and usage
- Enable quick rollbacks when needed
- Maintain consistent user experiences

Remember that you don't need to implement everything at once. Start with the basics, focus on reliability, and gradually add sophistication as your needs evolve.

Most importantly, while individual feature flags should be temporary and removed after feature stabilization, the feature flag system itself should be treated as critical infrastructure. The time invested in building a robust system will pay dividends in faster deployments, safer releases, and happier development teams.

> [!NOTE]
> Remember: The best feature flag system is one that's so reliable and easy to use that your team actually wants to use it. Feature flags should be a tool to help you ship faster, not a tool to slow you down.

## What's Next

In [Part 3: Feature Flags in the Real World](/articles/feature-flags-in-real-world), we'll look at how these implementations work in practice, including business considerations and real-world challenges.
